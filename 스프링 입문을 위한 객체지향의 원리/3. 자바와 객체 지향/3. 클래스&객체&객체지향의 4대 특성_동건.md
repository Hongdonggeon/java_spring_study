# 자바와 객체 지향



## 1. 객체 지향이란

우리가 눈으로 보고, 느끼고, 생활하는 현실 세계처럼 프로그래밍할 수는 없을까?라는 고민 속에서 객체 지향의 개념이 탄생했다.

기존 구조적 프로그래밍 언어에서 가장 중요한 것은 함수인데 함수를 처음 사용하면서 코드의 중복을 제거하고 논리의 분할을 하면서 프로그래밍이 더욱 편해졌다. 

그 후 객체 지향이 나왔다.

우주 만물은 객체들의 합이고 눈으로 보여지는 것, 손으로 만져지는 것, 머릿속으로 상상되는 모든것은 사물 (Object)이다. **"우리가 주변에서 사물을 인지하는 방식대로 프로그래밍 할 수 있지 않겠는가" 하는 것이 바로 객체 지향의 시작이다.**

객체 지향에서는 우리가 주변에서 실제 사물을 인지하는 방식대로 객체 단위의 프로그래밍이 가능하다.

객체 지향은 매우 인간적이고 직관적이다.



## 2. 클래스 vs 객체

많은 책들이 클래스와 객체의 관계를 '붕어빵틀 : 붕어빵'이라고 한다.

잘못된 설명이다.

우리가 객체를 객체를 생성하는 코드에 대입해보면, 

```
붕어빵틀 붕어빵 = new 붕어빵틀();
```

이해도 되지않고 말도 되지 않는다.

붕어빵틀은 붕어빵을 만드는 팩터리다.

그럼 **클래스와 객체는 어떻게 구분할까? 나이같은 특정 속성의 정확한 값을 가지고 있냐는 것**이다.

예를 들어 '사람의 나이는?'은 대답하지 못하지만 '동건의 나이는?'은 대답할 수 있다. 

사람은 클래스이고 동건은 객체이다.

**클래스는 분류에 대한 개념이지 실체가 아니다.**

**객체는 실체다.**



## 3. 객체 지향의 4대 특성 

객체 지향의 4대 특성 - 캡상추다

- 캡슐화(Encapsulation) : 정보 은닉
- 상속(extends) : 재사용
- 추상화(Abstraction) : 모델링
- 다형성(Polymrphism) : 사용 편의



### 1) 추상화 : 모델링

> 추상의 사전적 의미 : 여러 가지 사물이나 개념에서 공통되는 특성이나 속성 따위를 추출하여 파악하는 작용

사전적 의미에서 '공통 특성 / 공통 속성 추출'이라는 부분에 주목하자.

> - 추상화(미술)의 사전적 의미 : 사물의 사실적 재현이 아니고 순수한 점, 선, 면, 색체에 의한 표현을 목표로 한 그림. 일반적으로는 대상의 형태를 해체한 입체파 등의 회화도 포함된다.
>
> - 추상화의 사전적 의미 : 추상적인 것으로 됨 또는 그렇게 만듦

추상화는 구체적인 것을 분해해서 관찰자가 관심 있는 특성만 가지고 재조합하는 것이라고 정리할 수 있다.

객체 지향의 4대 특성은 클래스 또는 객체로 구현된다.

클래스는 실존하는 것이 아니기 때문에 실존하는 객체부터  의미를 생각해보겠다.

> 객체 : 세상에 존재하는 유일무이한 사물

> 클래스 : 분류, 집합, 같은 속성과 기능을 가진 객체를 총칭하는 개념

**세상에 존재하는 유일무이한 객체를 특성(속성 + 기능)에 따라 분류해 보니 객체를 통칭할 수 있는 집합적 개념, 즉 클래스가 나오게 된다.**

클래스의 가장 많이 사용되는 의미는 분류다. 따라서 객체들을 특성에 따라 분류했다는 의미가 된다.

```
사람 홍길동 = new 사람();
-> 사람이라는 클래스(분류) 를 이용해 유일무이하고 새로운 하나의 사람(객체)을 만들어 홍길동(객체 참조 변수) 라는 이름을 지어준 것이다.
```

개발자는 프로그램을 만드는 과정에서 애플리케이션의 창조자가 된다.

우리도 객체 지향 프로그래밍을 할 때 클래스를 먼저 설계하게 된다.

사람이라는 클래스를 설계할 때, 사람 객체들을 관찰해 사람 **객체들이 가진 공통된 특성**을 찾게 된다. 

ex) 몸무게, 키, 나이, 연봉, 먹다(), 자다().....

그리고 **애플리케이션의 경계(Context)**를 고려해야 한다. 애플리케이션 경계란 "**내가 만들고자 하는 애플리케이션은 어디에서 사용될 것인가**?"를 고려하고 필요 특성들을 간추리는 것이다.

ex) 병원 애플리케이션 - 사람(환자) : 시력, 몸무게, 혈액형, 먹다(),자다()

은행 애플리케이션 - 사람(고객) : 나이, 직업, 연봉, 출금하다(), 입금하다()  

#### 추상화란 구체적인 것을 분해해서 관심 영역(애플리케이션 경계)에 있는 특성만 가지고 재조합하는 것, 즉 모델링이다.

**자바는 객체 지향의 추상화를 class 키워드를 통해 지원하고 있다.**

**클래스와 객체 관계를 자바에서는 '클래스 객체_참조_변수 = new 클래스();' 로 표현한다.**



### 2) 상속 : 재사용 + 확장

객체 지향의 상속은 조직도의 개념이 아니다.

객체 지향의 상속은 재사용과 확장으로 이해하는 것이 맞다.

![6주차 과제: 상속](https://blog.kakaocdn.net/dn/egbLOk/btqQ1NIHUv4/UAeKRBG2b2lz1y3rmRL7lK/img.png)

동물은 포유류의 부모가 아니다. 또한 포유류는 고래의 부모가 아니다.

동물이라고 하는 것 중 분류를 조금 더 세분화해서 포유류와 조류가 나오고 포유류를 조금 더 분류해서 고래, 박쥐가 나오는 것이다.

**객체 지향에서의 상속은 상위 클래스의 특성을 하위 클래스에서 상속하고 거기에 더해 필요한 특성을 추가, 즉 확장해서 사용할 수 있다는 의미다.**

그런데 클래스의 특성을 상속한다는 말에서 특성을 빼고 클래스를 상속한다는 뜻으로 오해를 하니 부모 자식 관계가 나와버린 것이다.

앞으로는 '부모 클래스 - 자식 클래스'라는 표현보다는 **'상위 클래스 - 하위 클래스'** 또는 **'슈퍼 클래스 - 서브 클래스'**라고 표현하자.

상위 클래스 쪽으로 갈수록 추상화, 일반화됐다고 말하고, 하위 클래스 쪽으로 갈수록 구체화, 특수화 됐다고 말한다.

상속의 개념은 조직도나 계층도가 아닌 **분류도**다.

상속 관계에서 반드시 만족해야 하는 문장이 있다.

> - **하위 클래스는 상위 클래스다.**

위 문장을 조직도에 적용 시켜보면 적합하지 않다.

> 아버지는 할아버지다
>
> 아들은 아버지다

분류도에 적합해보면, 적합하다.

> 포유류는 동물이다.
>
> 고래는 포유류다.
>
> 고래는 동물이다. 

흥미로운게, 자바 언어에서 inheritance (상속)라는 키워드는 존재하지 않고 extends(확장) 가 존재한다.

**객체 지향 상속을 extends (확장)이라고 이해하자.**

여기서 상속에 대한 또 하나의 오해를 짚고 넘어가면 '상속은 is a 관계를 만족해야 할까?

> 펭귄 is a 동물
>
> 펭귄은 한 마리 동물이다

펭귄은 클래스고 동물도 클래스다. 그러나 한 마리 동물은 클래스가 아니라 객체다.

> 하위 클래스는 하나의 상위 클래스다
>
> 하위 클래스는 하나의 객체다.
>
> 하위 집단은 하나의 유일무이한 존재다

이렇게 되면 논리가 성립하지 않으므로 is a 관계로 많이 설명되고 있지만 더 명확한 표현이 있다.

**is kind of 관계다.**

마이크로 소프트 개발자 사이트인 MSDN에서도 상속을 표현하는 is a를 더 명확히 표현하면 a kind of라고 명시하고 있다.

> - 하위 클래스 is a kind of 상위 클래스
>
> - 펭귄 is a kind of 조류 -> 펭귄은 조류의 한 부류다.

자바는 c++에 있는 다중 상속을 포기하고 인터페이스를 도입했다.

다중 상속 대신이니 상속과 같이 is kind of일까? 그렇게 생각해도 사실 무관하지만 객체 지향이 긴 세월을 발전하다 보니 인터페이스 상속과는 다르게 쓰는 것이 유용하다는 결론에 도달하게 됐다.

- 인터페이스 : 구현 클래스 is able to 인터페이스
- 해석 : 구현 클래스는 인터페이스할 수 있다.
- ex) 고래는 헤엄칠 수 있다.

**인터페이스는 be able to, 즉 "무엇을 할 수 있는"이라는 표현 형태로 만드는 것이 좋다.**

상위 클래스는 물려줄 특성이 풍성할수록 좋고, 인터페이스는 구현을 강제할 메서드의 개수가 적을수록 좋다.

#### 객체 지향의 상속은 상위 클래스의 특성을 재사용하는 것이다.

#### 객체 지향의 상속은 상위 클래스의 특성을 확장하는 것이다.

#### 객체 지향의 상속은 is a kind of 관계를 만족해야 한다.



### 3) 다형성 : 사용편의성

객체 지향에서 다형성이라고 하면 **오버라이딩**과 **오버로딩**이라고 할 수 있다.

물론 상위 클래스와 하위 클래스 사이에서도 다형성을 이야기할 수 있고, 인터페이스와 그것의 구현 클래스 사이에서도 다형성을 이야기할 수 있지만 가장 기본은 오버라이딩과 오버로딩이라고 할 수 있다.

#### 오버라이딩

- 같은 메서드 이름, 같은 인자 목록으로 상위 클래스의 메서드를 재정의
- ride : 올라타다.
- 위에서 내려볼 때 오버라이딩 된 경우는 맨 위에 올라탄 존재만 보인다.

#### 오버로딩

- 같은 메서드 이름, 다른 인자 목록으로 다수의 메서드를 중복 정의
- load : 적재하다.
- 위에서 내려볼 때 오버로딩 된 경우는 옆으로 적재된 모든 적재물이 다 보인다.

#### 오버라이딩을 통한 메서드 재정의, 오버로딩을 통한 메서드 중복 정의를 통해 다형성을 제공하고 이 다형성이 개발자가 프로그램을 작성할 대 사용편의성을 준다.



### 4) 캡슐화 : 정보 은닉

자바에서 정보 은닉이라고 하면 접근 제어자인 private, default, protected, public이 생각날 것이다.

접근 제어자는 절대 단순하지 않다.

접근 제어자가 객체 멤버(인스턴스 멤버) 와 쓰일 때와 정적 멤버(클래스 멤버) 와 함께 쓰일 때를 비교해보겠다.

![image-20210910011830519](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210910011830519.png)



- 상속을 받지 않았더라면 객체 멤버는 객체를 생성한 후 객체 참조 변수를 이용해 접근해야 한다.
- 정적 멤버는 클래스명.정적멤버 형식으로 접근하는 것을 권장한다.

![image-20210910013523587](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210910013523587.png)

public 정적 속성인 pubSt의 경우라면 각 위치별 객체 멤버 메서드에서 접근할 수 있는 방법은 무려 세가지나 된다.

| classA      |                    | ClassA.pubSt | pubSt     | this.pubSt |
| ----------- | ------------------ | ------------ | --------- | ---------- |
| classA      |                    | 사용 가능    | 사용 가능 | 사용 가능  |
| 같은 패키지 | 상속한 경우        | 사용가능     | 사용 가능 | 사용 가능  |
|             | 상속하지 않은 경우 | 사용가능     | 사용 불가 | 사용 불가  |
| 다른 패키지 | 상속한 경우        | 사용가능     | 사용 가능 | 사용 가능  |
|             | 상속하지 않은 경우 | 사용가능     | 사용 불가 | 사용 불가  |

정적 멤버는 어떤 경우에 쓸까?

- 사람 클래스의 인구
- 고양이의 다리 개수

사람.인구, 고양이.다리개수 형식으로 접근하는 것이 홍길동.인구수, 키티.다리개수 형식으로 접근하는 것보다 권장된다. 

즉, 정적 멤버에 접근할 때는 클래스명.정적멤버 형식으로 접근하라는 것이다.

메모리의 물리적 접근에 따른 이유도 있다.

![image-20210910014325920](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210910014325920.png)
