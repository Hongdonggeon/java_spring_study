## 1. 자바 프로그램의 개발과 구동 Write Once Run Anywhere

현실 세계에서 컴퓨터를 구동하기 위해서는 물리적 컴퓨터인 하드웨어와 운영체제, 그리고 그 위에서 구동될 소프트웨어가 필요하다.

거기에 더해 소프트웨어를 개발할 수 있는 개발 도구가 필요하다.

자바의 가상 세계는 이러한 현실 세계를 그대로 모방하고 있다.

| 현실 세계                | 가상 세계            |                             |
| ------------------------ | -------------------- | --------------------------- |
| 소프트웨어 개발 도구     | JDK - 자바 개발 도구 | JVM 용 소프트웨어 개발 도구 |
| 운영체제                 | JRE - 자바 실행 환경 | JVM용 OS                    |
| 하드웨어 - 물리적 컴퓨터 | JVM - 자바 가상 기계 | 가상의 컴퓨터               |

현실 세계에서 소프트웨어, 즉 프로그램은 개발자가 개발 도구를 이용해 개발하고 운영체제를 통해 물리적 컴퓨터인 하드웨어 상에서 구동된다.

자바도 마찬가지로, 자바 개발 도구인 JDK를 이용해 개발된 프로그램은 JRE에 의해 가상의 컴퓨터인 JVM 상에서 구동된다.

다만 배포되는 JDK, JRE, JVM은 편의를 위해 JDK가 JRE를 포함하고 다시 JRE는 JVM을 포함하는 형태로 배포된다.

<img src="C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210823174321310.png" alt="image-20210823174321310" style="zoom: 80%;" />[-]

**JDK 는 자바 소스 컴파일러인 javac.exe를 포함하고 있다.**

**JRE는 자바 프로그램 실행기인 java.exe를 포함하고 있다.**

-> 기존 언어로 작성한 프로그램은 윈도우, 리눅스, 애플 맥 OS 용 등 각 플랫폼용으로 배포되는 설치 파일을 따로 준비해야 했던 불편함을 없애기 위해서다.

자바 개발자는 본인이 사용 중인 플랫폼에 설치된 JVM용으로 프로그램을 작성하고 배포하면 각 플랫폼에 맞는 JVM이 중재자로서 각 플랫폼에서 프로그램을 구동하는 데 아무 문제가 없게끔 만들어주는 것이다.

<br/>

## 2. 프로그램이 메모리를 사용하는 방식

<img src="C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210823182739851.png" alt="image-20210823182739851" style="zoom:80%;" />

위 그림은 하나의 프로그램이 실행될 때 메모리를 사용하는 방식이다.

기계어를 포함한 모든 프로그래밍 언어의 공통된 메모리 사용 방식이다.



<img src="C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210823182758019.png" alt="image-20210823182758019" style="zoom: 80%;" />

객체 지향 프로그램에서는 데이터 저장 영역을 다시 세 개의 영역으로 분할해서 사용한다.

- **스태틱 영역 - 클래스들의 놀이터**
- **스택 영역 - 메서드들의 놀이터**
- **힙 영역 - 객체들의 놀이터**



### 1) main() 메서드가 실행될 때 T 메모리에는 어떤 일이 일어나는가?

```java
public class Start {
    public static void main(String[] args){
        System.out.println("Hello OOP!!");
    }
}
```

- **스태틱 영역**

  - main() 메서드의 존재가 확인되면 JRE는 JVM에 전원을 넣어 부팅한다.
  - 부팅된 JVM은 목적 파일을 받아 그 목적 파일을 실행하고 전처리 과정을 거친다.

  > JVM에서 수행하는 전처리 작업들
  >
  > - java.lang 패키지를 T 메모리의 스태틱 영역에 배치
  > - import 된 패키지를 T 메모리의 스태틱 영역에 배치
  > - 프로그램 상의 모든 클래스를 T 메모리의 스태틱 영역에 배치

  ![image-20210907101159855](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210907101159855.png)

![image-20210907101227254](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210907101227254.png)



- **스택 영역**
  - main() 메서드가 놀기 위해 스택 프레임이 스택영역에 할당된다.
  - 여는 중괄호를 만날때 마다 스택 프레임이 하나씩 생긴다. (클래스 정의 시작 중괄호 제외)zxs
  - ![image-20210907101715957](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210907101715957.png)
  - 메서드의 인자 args를 저장할 변수 공간을 맨 밑에 확보한다. (메서드 인자의 변수 공간 할당)
  - ![image-20210907101947061](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210907101947061.png)
  - 위의 그림처럼 T 메모리를 구성하고 나서야 main() 메서드 안의 첫 명령문을 실행하게 된다.



메모리에서 코드 실행 공간은 별도로 있었다. System.out.println() 구문이 코드 실행 공간에서 실행되면 GPU에 화면을 출력 의뢰하게 되고 데이터 저장 공간인 T메모리에는 아무런 변화가 없다.

모든 구문을 실행을 하고 **main() 메서드의 끝을 나타내는 닫는 중괄호를 만나면 스택 프레임이 소멸된다.**

**main() 메서드가 끝나면 JRE는 JVM을 종료하고 JRE 자체도 운영체제 상의 메모리에서 사라진다.**



### 2) 변수와 메모리

```java
public class Start2 {
    public static void main(String[] args){
        int i;
        i = 10;
        
        double d = 20.0;
    }
}
```



#### 메모리 변화

main() 메서드 스택 프레임 안에 밑에서부터 차곡차곡 변수 공간을 마련한다.

![image-20210915180705516](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210915180705516.png)



![image-20210915180642423](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210915180642423.png)

- 초기화되지 않은 상태다.

![image-20210915180732547](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210915180732547.png)

![image-20210915180758661](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210915180758661.png)

- 하나의 명령문이 아니라 두 개의 명령문이다.
- 변수를 선언하는 명령문과 변수에 값을 할당하는 명령문 두 개가 한 줄에 있는 것이다.

7번째 줄의 닫는 중괄호로 main() 메서드 스택 프레임이 스택 영역에서 사라진다.



### 3) 블록 구분과 메모리

```java
public class Start3 {
    public static void main(String[] args){
        int i = 10;
        int k = 20;
        
        if(i == 10) {
            int m = k + 5;
            k = m;
        } else {
            int p = k + 10;
            k = p;
        }
        
        // k = m + p;
        }
    }
}
```



#### 메모리 변화

![image-20210915182020863](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210915182020863.png)



![image-20210915182040710](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210915182040710.png)

- 여는 중괄호를 만나면 스택 프레임이 시작된다고 했는데 여기서 만들어지는 스택 프레임은 메서드의 스택 프레임이 아니라 if 문, 참인 블록의 스택 프레임이다.
- main() 메서드의 스택 프레임 안에 if 문의 블록 스택 프레임이 중첩되어 생성된다.

![image-20210915182056582](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210915182056582.png)

![image-20210915182124236](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210915182124236.png)



![image-20210915182137911](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210915182137911.png)



![image-20210915182209644](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210915182209644.png)

- 9번째 줄에서 if 블록 중 참일 때의 블록을 종료하는 닫는 중괄호를 만나면 if 블록 스택 프레임은 스택 영역에서 사라진다. 이때 if 블록 스택 프레임 안에 상주하던 변수의 저장 공간도 함께 사라진다.

위의 주석을 제거하면 T메모리에 m 변수와 p 변수는 존재하지 않기 때문에 컴파일 에러가 발생한다.

여기서도 마찬가지로, main() 메서드 스택 프레임을 소멸시키는 블록 마침 기호인 닫는 중괄호를 만나면 T 메모리가 소멸되고, JVM 기동 중지, JRE가 사용했던 시스템 자원을 운영체제에 반납하게 된다.



### 6) 지역 변수와 메모리

T 메모리는 세 개의 영역이 있는데 변수는 스태틱 영역, 스택 영역, 힙 영역 세 군데에 모두 있다.

그런데 세 군데 각각에 있는 변수는 각기 다른 목적을 가진다.

- 지역 변수 : 스택 영역에서 일생을 보낸다. 그것도 스택 프레임 안에서 일생을 보내게 된다. 따라서 스택 프레임이 사라지면 함께 사라진다.
- 클래스 멤버 변수 : 스태틱 영역에서 일생을 보낸다. 스태틱 영역에 한번 자리 잡으면 JVM이 종료될 때까지 고정된 상태로 그 자리를 지킨다.
- 객체 멤버 변수 : 힙에서 일생을 보낸다. 객체 멤버 변수들은 객체와 함께 가비지 컬렉터라고 하는 힙 메모리 회수기에 의해 일생을 마치게 된다.

```java
public class Start3 {
    public static void main(String[] args){
        int i = 10;
        int k = 20;
        
        if(i == 10) {
            int m = k + 5;
            k = m;
        } else {
            int p = k + 10;
            k = p;
        }
        
        // k = m + p;
        }
    }
}
```

![image-20210915182056582](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210915182056582.png)

7번째 줄에서 주목할 것은 if 블록 스택 프레임을 수행하는 중에 if 블록 스택 프레임 외부에 존재하는 변수 k는 접근이 가능하다. 메모리 상에 변수 k가 존재하니 당연히 접근이 가능하다.

**외부 스택 프레임에서 내부 스택 프레임의 변수에 접근하는 것은 불가능하나 내부 스택 프레임에서 외부 스택 프레임의 변수에 접근하는 것은 가능하다.**



### 7) 메서드 호출과 메모리 

```java
public class Start4 {
    public static void main(String[] args){
        int k = 5;
        int m;
        
        m = square(k);
    }
    
    private static int square(int k){
        int result;
        
        k = 25;
        
        result = k;
        
        return result;
    }
}
```



#### 메모리 변화

![image-20210915192711007](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210915192711007.png)

- 6번째 줄에서 square() 메서드를 호출하고 있다. square() 메서드는 인자값도 있고 반환값도 있다.
- 제어 흐름이 square() 메서드가 선언된 9번째 줄로 이동할 것이다.

![image-20210915192838106](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210915192838106.png)

- 11 번째 라인에 의해 생성되는 square() 메서드 스택 프레임에는 반환값을 저장할 변수 공간이 맨 아래, 그다음으로 인자를 저장할 변수 공간, 마지막으로 메서드의 지역 변수가 자리 잡는다.

![image-20210915192927656](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210915192927656.png)

- main() 메서드가 가진 변수 k와 square() 메서드가 가진 변수 k가 이름만 같지 실제로는 서로 별도의 변수 공간이라는 것이다. 이것을 전문 용어로 Call By Value라 한다. 그래서 square() 메서드 안의 k 변수에 무슨 짓을 해도 main() 메서드 안의 k 변수는 영향이 없다.

![image-20210915192945058](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210915192945058.png)

17 번째 줄에서 square() 메서드의 끝을 알리는 닫는 중괄호를 만나면 square() 메서드 스택 프레임은 스택에서 사라진다.그런데 반환값이 있으니 그 값을 돌려주면서 스택에서 사라진다.

![image-20210915193808164](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210915193808164.png)

7번째 줄의 닫는 중괄호는 main() 메서드 스택 프레임을 메모리에서 사라지게 하고, 결국 모든 프로그램이 종료된다.

![image-20210915201020071](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210915201020071.png)

- 입력값들과 반환값에 의해서만 메서드 사이에서 값이 전달될 뿐 서로 내부의 지역 변수를 볼 수 없다.



### 8) 전역 변수와 메모리

```java
public class Start5{
    static int share;
    
    public static void main(String[] args) {
        share = 55;
        int k = fun(5,7);
        
        System.out.println(share);
    }
    
    private static int fun(int m, int p) {
        share = m + p;
        
        return m - p;
    }
}
```

![image-20210915202707537](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210915202707537.png)

![image-20210915202732101](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210915202732101.png)

![image-20210915202849477](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210915202849477.png)

- fun() 메서드가 있는 12번째 줄로 넘어간다. fun() 메서드 스택 프레임이 생성되고 인자값들과 반환값을 저장할 변수 공간도 생긴다.

![image-20210915203047888](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210915203047888.png)

- m 변수와 p 변수에 있는 값을 더해 share 변수에 할당한 상태가 된다.

<img src="C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210915203347284.png" alt="image-20210915203347284" style="zoom:150%;" />

- 16번째 줄의 닫는 중괄호를 만나면 fun() 메서드 스택 프레임이 사라지면서 호출된 곳으로 반환 값을 돌려준다.

<img src="C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210915203537309.png" alt="image-20210915203537309" style="zoom:150%;" />

- 8번째 줄의 닫는 중괄호를 만나면 main() 메서드 스택 프레임이 사라지고, main() 메서드가 종료되면 T 메모리도 반납된다.



메서드 밖에서 선언된 변수 share는 메서드들 사이에서 공유해서 사용할 수 있는 전역 변수가 된다.

- 스택 프레임에 종속적인 지역 변수
- 스택 프레임에 독립적인 전역 변수

전역 변수는 코드 어느 곳에서나 접근할 수 있다고 해서 전역 변수라고 하며, 여러 메서드들이 공유해서 사용한다고 해서 공유 변수라고도 한다.

> 전역 변수를 사용하지 말라고 하는 이유는?
>
> 프로젝트 규모에 따라 코드가 커지면서 여러 메서드에서 전역 변수의 값을 변경하기 시작하면 T 메모리로 추적하지 않는 이상 전역 변수에 저장돼 있는 값을 파악하기 쉽지 않기 때문이다.

전역 상수로 쓰는 것은 적극 추천한다. ex) 원주율



### 멀티 스레드 / 멀티 프로세스의 이해

#### 멀티 스레드

- 멀티 스레드의 T 메모리 모델은 스택 영역을 스래드 개수만큼 분할해서 쓰는 것이다.
- 멀티 스레드는 하나의 T 메모리 안에서 스택 영역만 분할한 것이기 때문에 하나의 스레드에서 다른 스레드의 스택 영역에는 접근할 수 없지만 스태틱 영역과 힙 영역은 공유해서 사용하는 구조다.

![image-20210915205249649](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210915205249649.png)



#### 멀티 프로세스

- 멀티 프로세스는 다수의 데이터 저장 영역, 즉 다수의 T 메모리를 갖는 구조다.
- 멀티 프로세스는 하나의 프로세스가 다른 프로세스의 T 메모리 영역을 절대 침범할 수 없는 메모리 안전한 구조이지만 메모리 사용량은 그만큼 크다

![image-20210915205327200](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210915205327200.png)



**멀티 스레드에서 전역 변수 사용 문제점**

![image-20210915220652505](C:\Users\홍동건\AppData\Roaming\Typora\typora-user-images\image-20210915220652505.png)

